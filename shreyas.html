<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDG 9: Industry, Innovation, and Infrastructure</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            color: #2c3e50;
        }
        h2 {
            color: #2980b9;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
    </style>
</head>
<body>
    <h1>SDG 9: Industry, Innovation, and Infrastructure</h1>
    <h2>Targets</h2>
    <ul>
        <li><strong>9.1:</strong> Develop quality, reliable, sustainable, and resilient infrastructure to support economic development and human well-being.</li>
        <li><strong>9.2:</strong> Promote inclusive and sustainable industrialization.</li>
        <li><strong>9.4:</strong> Upgrade infrastructure and retrofit industries to make them sustainable, with increased resource-use efficiency and clean technologies.</li>
    </ul>
    
    <h2>Indicators</h2>
    <ul>
        <li><strong>9.1.1:</strong> Proportion of the rural population who live within 2 km of an all-season road.</li>
        <li><strong>9.1.2:</strong> Passenger and freight volumes by mode of transport.</li>
        <li><strong>9.2.1:</strong> Manufacturing value added as a proportion of GDP and per capita.</li>
        <li><strong>9.4.1:</strong> CO2 emissions per unit of value added.</li>
    </ul>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            color: #2c3e50;
        }
        h2 {
            color: #2980b9;
        }
        ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Course Learning Reflections</h1>

    <h2>1. What are the kinds of problems we see in nature?</h2>
    <ul>
        <li><strong>Iteration:</strong> Problems that require repetitive actions, like simulating natural processes (e.g., daily weather patterns or population growth modeling).</li>
        <li><strong>Recursion:</strong> Problems like fractal generation, hierarchical organization (e.g., family trees), or solving complex puzzles like the Tower of Hanoi.</li>
        <li><strong>Backtracking:</strong> Problems involving decision-making, such as solving mazes, finding paths in graphs, or placing queens on a chessboard without conflicts (N-Queens problem).</li>
    </ul>

    <h2>2. What is space and time efficiency, and why are they important?</h2>
    <ul>
        <li><strong>Space Efficiency:</strong> Refers to the amount of memory a program uses. It’s crucial for solving large-scale problems or working in memory-constrained environments (e.g., embedded systems).</li>
        <li><strong>Time Efficiency:</strong> Measures how quickly an algorithm executes. It ensures scalable solutions that remain feasible as problem sizes increase.</li>
        <li><strong>Classes of Problems:</strong> Algorithms are often analyzed using <em>Big O notation</em> to classify their performance:
            <ul>
                <li><strong>Constant Time (O(1)):</strong> Direct access in arrays.</li>
                <li><strong>Logarithmic Time (O(log n)):</strong> Binary search.</li>
                <li><strong>Linear Time (O(n)):</strong> Single loop operations.</li>
                <li><strong>Quadratic Time (O(n²)):</strong> Nested loops (e.g., bubble sort).</li>
            </ul>
        </li>
    </ul>

    <h2>3. Takeaways from different design principles (from Chapter 2):</h2>
    <ul>
        <li><strong>Divide and Conquer:</strong> Breaking problems into smaller subproblems (e.g., Merge Sort, Quick Sort).</li>
        <li><strong>Dynamic Programming:</strong> Solving overlapping subproblems and storing results (e.g., Fibonacci series).</li>
        <li><strong>Greedy Algorithms:</strong> Making locally optimal choices at each stage (e.g., Dijkstra's shortest path).</li>
        <li><strong>Backtracking:</strong> Exploring all possibilities while pruning non-feasible solutions (e.g., solving Sudoku).</li>
    </ul>

    <h2>4. The hierarchical data and tree structures</h2>
    <ul>
        <li><strong>Tree Data Structures:</strong> Useful for representing hierarchical data, such as:
            <ul>
                <li><strong>Binary Search Tree (BST):</strong> Efficient searching and insertion.</li>
                <li><strong>AVL Trees:</strong> Self-balancing for maintaining performance.</li>
                <li><strong>Red-Black Trees:</strong> Balancing for databases.</li>
                <li><strong>Heap Trees:</strong> Priority queues.</li>
                <li><strong>Tries:</strong> Efficient prefix searches (e.g., autocomplete).</li>
            </ul>
        </li>
        <li><strong>Real-world Applications:</strong>
            <ul>
                <li>Organizing file systems.</li>
                <li>Decision-making in AI (e.g., game trees).</li>
                <li>Representing and querying hierarchical relationships.</li>
            </ul>
        </li>
    </ul>

    <h2>5. Need for array query algorithms</h2>
    <ul>
        <li><strong>Applications:</strong>
            <ul>
                <li><strong>Range Queries:</strong> Used in database systems or financial analysis.</li>
                <li><strong>Segment Trees:</strong> Efficient for range queries and updates.</li>
                <li><strong>Fenwick Trees:</strong> Efficient cumulative frequency computations.</li>
            </ul>
        </li>
        <li><strong>Implications:</strong> Improves performance of real-time analytics and data retrieval.</li>
    </ul>

    <h2>6. Differences between trees and graphs</h2>
    <ul>
        <li><strong>Trees:</strong>
            <ul>
                <li>Hierarchical and acyclic.</li>
                <li>Single unique path between any two nodes.</li>
                <li>Used in data structures like heaps and tries.</li>
            </ul>
        </li>
        <li><strong>Graphs:</strong>
            <ul>
                <li>Generalized structure with nodes and edges (can be cyclic).</li>
                <li>Used for networks (social, transportation, communication).</li>
            </ul>
        </li>
        <li><strong>Traversal:</strong>
            <ul>
                <li><strong>Trees:</strong> Depth-First Search (DFS), Breadth-First Search (BFS).</li>
                <li><strong>Graphs:</strong> Additional considerations for cycles and disconnected components.</li>
            </ul>
        </li>
    </ul>

    <h2>7. Sorting and searching algorithms</h2>
    <ul>
        <li><strong>Sorting Algorithms:</strong>
            <ul>
                <li><strong>Quick Sort:</strong> Divide and conquer, efficient for large datasets.</li>
                <li><strong>Merge Sort:</strong> Stable and predictable performance.</li>
            </ul>
        </li>
        <li><strong>Searching Algorithms:</strong>
            <ul>
                <li><strong>Linear Search:</strong> Simple, checks elements one by one.</li>
                <li><strong>Binary Search:</strong> Requires sorted data, faster for large datasets.</li>
            </ul>
        </li>
        <li><strong>Real-world Applications:</strong>
            <ul>
                <li>Sorting datasets for analysis.</li>
                <li>Searching in e-commerce platforms or search engines.</li>
            </ul>
        </li>
    </ul>

    <h2>8. Graph algorithms and shortest paths</h2>
    <ul>
        <li><strong>Spanning Trees:</strong> Minimal connections in a graph without cycles (e.g., Minimum Spanning Tree for network design).</li>
        <li><strong>Shortest Paths:</strong>
            <ul>
                <li><strong>Dijkstra’s Algorithm:</strong> Finds shortest paths in weighted graphs.</li>
                <li><strong>Bellman-Ford Algorithm:</strong> Works with graphs having negative weights.</li>
            </ul>
        </li>
        <li><strong>Applications:</strong> Navigation systems, network routing.</li>
    </ul>

    <h2>9. Algorithm design techniques</h2>
    <ul>
        <li><strong>Brute Force:</strong> Simple but inefficient (e.g., generating all combinations).</li>
        <li><strong>Dynamic Programming:</strong> Optimized for overlapping subproblems (e.g., knapsack problem).</li>
        <li><strong>Greedy:</strong> Quick and intuitive solutions for optimization problems.</li>
        <li><strong>Divide and Conquer:</strong> Foundational for efficient algorithms like mergesort and binary search.</li>
    </ul>
</body>
</html>
