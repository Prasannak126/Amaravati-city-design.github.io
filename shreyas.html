<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDG 11 Infrastructure and Business Case Study</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            background-color: #121212;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            line-height: 1.6;
        }

        h2 {
            font-size: 2.5em;
            color: #f1c27d;
            margin-bottom: 20px;
        }

        h3 {
            font-size: 1.8em;
            color: #f1c27d;
            margin-top: 30px;
        }

        ul {
            list-style-type: none;
            padding: 0;
            margin-top: 10px;
        }

        ul li {
            margin: 5px 0;
            font-size: 1.2em;
        }

        strong {
            color: #f1c27d;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 10px;
        }

        a {
            color: #f1c27d;
            text-decoration: none;
            font-weight: 600;
        }

        a:hover {
            color: #ffffff;
        }

        p {
            font-size: 1.1em;
            line-height: 1.8;
        }

        blockquote {
            font-size: 1.5em;
            font-style: italic;
            color: #f1c27d;
            margin: 20px 0;
            padding: 20px;
            border-left: 5px solid #f1c27d;
            background-color: #222222;
        }
    </style>
</head>
<body>

    <div class="section">
        <h2>1. Best Target and Indicator of SDG 11 Infrastructure</h2>
        <p><strong>Target 11.2:</strong> By 2030, provide access to safe, affordable, accessible, and sustainable transport systems for all, improving road safety, notably by expanding public transport, with special attention to the needs of those in vulnerable situations, women, children, persons with disabilities, and older persons.</p>
        <p><strong>Indicator 11.2.1:</strong> Proportion of population that has convenient access to public transport, by sex, age, and persons with disabilities.</p>
    </div>

    <div class="section">
        <h2>2. Reflection on the Business Case Study</h2>

        <h3>2.1 Types of Problems in Nature</h3>
        <p>Many computational problems can be categorized based on how they are solved, particularly using iterative, recursive, or backtracking approaches:</p>
        <ul>
            <li><strong>Iteration:</strong> Involves repeating a set of instructions until a condition is met. Common in problems where you know the number of iterations ahead of time.</li>
            <li><strong>Recursion:</strong> Occurs when a function calls itself to solve a smaller version of the problem. It's useful when the problem can naturally be divided into subproblems.</li>
            <li><strong>Backtracking:</strong> Used for problems involving choices, where you explore all possibilities and "backtrack" when a dead-end is reached (e.g., puzzles like Sudoku, N-Queens problem).</li>
        </ul>

        <h3>2.2 Space and Time Efficiency</h3>
        <p>Space and time efficiency refer to how efficiently an algorithm uses computer resources (memory and time) to solve a problem.</p>
        <ul>
            <li><strong>Time Efficiency:</strong> Measured by how fast an algorithm runs as the input size grows. It is often expressed using Big O notation (e.g., O(n), O(n²)).</li>
            <li><strong>Space Efficiency:</strong> Refers to the amount of memory the algorithm uses during its execution. Similarly, it is also expressed in Big O notation (e.g., O(1) for constant space, O(n) for linear space).</li>
        </ul>
        <p><strong>Class of Problems and Orders of Growth:</strong></p>
        <ul>
            <li><strong>Constant Time:</strong> O(1) - Algorithm takes the same amount of time regardless of the input size (e.g., accessing an array element).</li>
            <li><strong>Linear Time:</strong> O(n) - Time grows linearly with the size of the input (e.g., linear search).</li>
            <li><strong>Quadratic Time:</strong> O(n²) - Time grows quadratically (e.g., bubble sort, insertion sort).</li>
            <li><strong>Logarithmic Time:</strong> O(log n) - Time grows logarithmically (e.g., binary search).</li>
            <li><strong>Exponential Time:</strong> O(2ⁿ) - Time grows exponentially (e.g., brute force approaches to problems like traveling salesman).</li>
        </ul>

        <h3>2.3 Design Principles from Chapter 2</h3>
        <p>Key takeaways from design principles include:</p>
        <ul>
            <li><strong>Divide and Conquer:</strong> Break a problem into smaller subproblems, solve each recursively, and combine the results.</li>
            <li><strong>Greedy Algorithms:</strong> Make the locally optimal choice at each step, hoping it leads to a globally optimal solution.</li>
            <li><strong>Dynamic Programming:</strong> Break problems into overlapping subproblems and store solutions to avoid redundant work.</li>
        </ul>

        <h3>2.4 Hierarchical Data and Tree Data Structures</h3>
        <p>Tree data structures are excellent for modeling hierarchical data and optimizing search and insertion operations:</p>
        <ul>
            <li><strong>Binary Tree:</strong> Each node has at most two children, left and right.</li>
            <li><strong>Binary Search Tree (BST):</strong> A binary tree where the left child is smaller and the right child is larger than the parent node.</li>
            <li><strong>AVL Tree:</strong> A self-balancing BST with height difference at most 1, ensuring O(log n) operations.</li>
            <li><strong>2-3 Tree:</strong> A tree where each node can have two or three children.</li>
            <li><strong>Red-Black Tree:</strong> A self-balancing BST ensuring operations remain O(log n).</li>
            <li><strong>Heap:</strong> A tree-based data structure useful for priority queues.</li>
            <li><strong>Trie:</strong> A specialized tree for storing strings, used in dictionary and search applications.</li>
        </ul>

        <h3>2.5 Array Query Algorithms</h3>
        <p>These algorithms help in efficiently retrieving or updating elements in an array:</p>
        <ul>
            <li><strong>Prefix Sum:</strong> Preprocesses an array so the sum of any subarray can be queried in constant time.</li>
            <li><strong>Segment Tree:</strong> A tree-based data structure for efficiently answering range queries and updates.</li>
        </ul>

        <h3>2.6 Trees vs. Graphs</h3>
        <p>Comparison of trees and graphs, their traversal techniques, and applications:</p>
        <ul>
            <li><strong>Tree:</strong> A hierarchical structure with a single root node. Traversals include pre-order, in-order, and post-order.</li>
            <li><strong>Graph:</strong> A non-hierarchical structure with nodes and edges that can form cycles. Traversals include Depth-First Search (DFS) and Breadth-First Search (BFS).</li>
        </ul>

        <h3>2.7 Sorting and Searching Algorithms</h3>
        <p>Deliberation on sorting and searching algorithms, their techniques, and real-world connections:</p>
        <ul>
            <li><strong>Sorting Algorithms:</strong> Bubble Sort, Merge Sort, Quick Sort.</li>
            <li><strong>Searching Algorithms:</strong> Linear Search, Binary Search.</li>
        </ul>
      </div>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
            background-color: #f9f9f9;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
        }
        h2 {
            color: #34495e;
            margin-top: 20px;
        }
        h3 {
            color: #5d6d7e;
            margin-top: 15px;
        }
        ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        li {
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Course Learning Reflections</h1>

    <h2>What are the kinds of problems we see in nature?</h2>
    <p>We often encounter problems in the following categories:</p>
    <ul>
        <li><strong>Iteration:</strong> Problems that require repeating a process until a condition is met. For example, traversing a list of items.</li>
        <li><strong>Recursion:</strong> Problems that can be broken down into smaller sub-problems. For instance, computing factorials or solving Tower of Hanoi.</li>
        <li><strong>Backtracking:</strong> Problems that involve exploring all possible solutions and abandoning paths that fail. Examples include solving mazes and the N-Queens problem.</li>
    </ul>

    <h2>What is space and time efficiency? Why are they important?</h2>
    <p>Space and time efficiency are key concepts in algorithm design:</p>
    <ul>
        <li><strong>Space Efficiency:</strong> Refers to the amount of memory an algorithm uses. Optimizing space is critical for large-scale data processing or resource-constrained devices.</li>
        <li><strong>Time Efficiency:</strong> Refers to the amount of time an algorithm takes to complete. Faster algorithms improve user experience and reduce computational costs.</li>
    </ul>
    <p>Classes of problems and orders of growth:</p>
    <ul>
        <li><strong>Constant Time (O(1)):</strong> Independent of input size. Example: Accessing an element in an array.</li>
        <li><strong>Logarithmic Time (O(log n)):</strong> Reduces problem size at each step. Example: Binary search.</li>
        <li><strong>Linear Time (O(n)):</strong> Grows linearly with input size. Example: Iterating over an array.</li>
        <li><strong>Quadratic Time (O(n²)):</strong> Nested loops. Example: Bubble sort.</li>
        <li><strong>Exponential Time (O(2ⁿ)):</strong> Grows exponentially. Example: Solving the Traveling Salesman problem.</li>
    </ul>

    <h2>Takeaways from Design Principles (Chapter 2)</h2>
    <ul>
        <li>Understand the problem before designing an algorithm.</li>
        <li>Focus on modularity and simplicity in solutions.</li>
        <li>Optimize for both time and space constraints.</li>
        <li>Use abstraction to reduce complexity and improve clarity.</li>
    </ul>

    <h2>The Hierarchical Data and Tree Data Structures</h2>
    <p>Hierarchical data structures like trees organize data in a parent-child relationship. Different tree types solve specific problems:</p>
    <ul>
        <li><strong>Tree:</strong> General-purpose hierarchical structure. Example: File systems.</li>
        <li><strong>Binary Search Tree (BST):</strong> Allows quick search, insert, and delete operations.</li>
        <li><strong>AVL Tree:</strong> Self-balancing BST to maintain performance.</li>
        <li><strong>2-3 Tree:</strong> Guarantees balanced structure, commonly used in databases.</li>
        <li><strong>Red-Black Tree:</strong> Ensures balance with color-based rules, used in maps and sets.</li>
        <li><strong>Heap:</strong> Used in priority queues and efficient sorting.</li>
        <li><strong>Trie:</strong> Efficiently stores and retrieves strings, used in autocomplete features.</li>
    </ul>

    <h2>The Need for Array Query Algorithms</h2>
    <p>Array query algorithms optimize tasks like searching, sorting, and range queries:</p>
    <ul>
        <li>Improves performance in data retrieval and updates.</li>
        <li>Examples: Binary search, segment trees, and Fenwick trees.</li>
    </ul>

    <h2>Trees vs. Graphs</h2>
    <p>Key differences between trees and graphs:</p>
    <ul>
        <li><strong>Trees:</strong> Connected and acyclic. Applications: Hierarchies, decision-making processes.</li>
        <li><strong>Graphs:</strong> May have cycles and are more general. Applications: Social networks, transportation networks.</li>
    </ul>
    <p>Traversal techniques:</p>
    <ul>
        <li>Tree Traversal: Preorder, Inorder, Postorder.</li>
        <li>Graph Traversal: Depth-First Search (DFS), Breadth-First Search (BFS).</li>
    </ul>

    <h2>Sorting and Searching Algorithms</h2>
    <p>Sorting and searching algorithms are fundamental in data processing:</p>
    <ul>
        <li><strong>Sorting:</strong> Organizes data for efficient access. Examples: Merge sort, Quick sort.</li>
        <li><strong>Searching:</strong> Finds data efficiently. Examples: Binary search.</li>
    </ul>

    <h2>Graph Algorithms</h2>
    <p>Graph algorithms address connectivity and optimization problems:</p>
    <ul>
        <li><strong>Spanning Trees:</strong> Minimum spanning trees (e.g., Kruskal’s algorithm) optimize connectivity.</li>
        <li><strong>Shortest Path Algorithms:</strong> Dijkstra’s and Bellman-Ford algorithms find optimal routes.</li>
    </ul>

    <h2>Algorithm Design Techniques</h2>
    <p>Studied algorithm design techniques include:</p>
    <ul>
        <li>Divide and Conquer.</li>
        <li>Dynamic Programming.</li>
        <li>Greedy Algorithms.</li>
        <li>Backtracking and Branch-and-Bound.</li>
    </ul>
</body>
</html>
