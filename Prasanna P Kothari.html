<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Course Overview</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <header>
        <h1>Algorithm Course Overview</h1>
    </header>
    
    <section>
        <h2>1. Problems in Nature</h2>
        <p><strong>Recursion:</strong> Uncontrolled recursion, like in cancer, can lead to exponential growth.</p>
        <p><strong>Iteration:</strong> Iterative cycles can be disrupted by climate change, leading to irregular seasons or extreme weather patterns.</p>
        <p><strong>Backtracking:</strong> Migratory species may encounter obstacles and fail to backtrack to alternative routes.</p>
    </section>
    
    <section>
        <h2>2. Space and Time Efficiency</h2>
        <p><strong>Space Efficiency:</strong> Extra space required by an algorithm.</p>
        <p><strong>Time Efficiency:</strong> Extra time required by an algorithm.</p>
        <p><strong>Why Important?</strong> Space and time efficiency are vital for building systems that are fast, scalable, and sustainable, ensuring optimal performance across real-world applications.</p>
        
        <h3>Orders of Growth</h3>
        <ul>
            <li>O(1) - Constant</li>
            <li>O(n) - Linear</li>
            <li>O(log n) - Logarithmic</li>
            <li>O(n<sup>2</sup>) - Quadratic</li>
            <li>O(n log n) - Linearithmic</li>
            <li>O(n<sup>3</sup>) - Cubic</li>
            <li>O(n<sup>k</sup>) - Polynomial</li>
            <li>O(2<sup>n</sup>) - Exponential</li>
            <li>O(n!) - Factorial</li>
        </ul>
    </section>
    
    <section>
        <h2>3. Takeaway from Different Design Principles</h2>
        <h3>Sorting Algorithms</h3>
        <ul>
            <li><strong>Bubble Sort:</strong> Simple to understand and implement, best for small datasets.</li>
            <li><strong>Selection Sort:</strong> Minimal swaps compared to bubble sort but not adaptive.</li>
            <li><strong>Insertion Sort:</strong> Efficient for partially sorted datasets.</li>
            <li><strong>Merge Sort:</strong> Stable and efficient for large dataset sorting.</li>
            <li><strong>Quick Sort:</strong> In-place but not stable, efficient for large datasets.</li>
            <li><strong>Heap Sort:</strong> In-place but not stable.</li>
            <li><strong>Boyer More Algorithm:</strong> Effective for long texts and patterns. Utilizes pre-computation for optimal performance but requires extra space for preprocessing.</li>
            <li><strong>Kruskal’s algorithm:</strong> Requires cycle detection, often implemented using union-find data structure. Suitable for sparse graphs.</li>
            <li><strong>Dijkstra’s algorithm:</strong> Provides optimal solutions for single-source shortest paths in directed or undirected graphs.</li>
            <li><strong>Floyd’s algorithm:</strong> Based on the principle of Kleene’s Theorem. All-pairs shortest path algorithm.</li>
            <li><strong>Warshall’s algorithm:</strong> Based on the principle of Kleene’s theorem. Transitive closure algorithm. We can try to make the algorithm run faster by treating matrix as bit strings and employing bitwise operations.</li>
            <li><strong>Prim’s Algorithm:</strong> Prim’s is based on the edge relaxation principle. Minimum spanning tree algorithm. Falls under the Greedy technique.</li>
        </ul>
    </section>
    
    <section>
        <h2>4. Hierarchical Data and Tree Data Structures</h2>
        <ul>
            <li><strong>Tree:</strong> Flexible but search or traversal may take O(n) due to lack of ordering or balancing.</li>
            <li><strong>BST:</strong> Reduces the complexity of search operations to O(log n) on average by maintaining sorted order.</li>
            <li><strong>AVL Tree:</strong> Balances the tree after every insertion or deletion, ensuring O(log n) operations.</li>
            <li><strong>2-3 Tree:</strong> Always balanced, handling multiple keys in each node.</li>
            <li><strong>Red-Black Tree:</strong> Less strict balancing, reducing the overhead of rotations during updates.</li>
            <li><strong>Heap:</strong> Guarantees O(1) for finding max/min and O(log n) for insertions and deletions.</li>
            <li><strong>Trie:</strong> Exploits shared prefixes, ideal for large datasets with overlapping entries.</li>
        </ul>
    </section>
    
    <section>
        <h2>5. Array Query Algorithms</h2>
        <p>Array query algorithms include Fenwick Tree, Segment Tree, Lookup Table. These algorithms are essential for efficiently processing, retrieving, and analyzing data stored in arrays, especially with large datasets or frequently repeated queries.</p>
        <ul>
            <li><strong>Fenwick Tree:</strong>
                <ul>
                    <li>Principle: Supports efficient range queries and point updates.</li>
                    <li>Application: Cumulative frequency counts in online queries.</li>
                </ul>
            </li>
            <li><strong>Segment Tree:</strong>
                <ul>
                    <li>Principle: Divides array into segments for range queries and updates.</li>
                    <li>Application: Dynamic histograms.</li>
                </ul>
            </li>
            <li><strong>Lookup Table:</strong>
                <ul>
                    <li>Principle: Precomputes results for all possible inputs.</li>
                    <li>Application: Collision detection, AI decision trees.</li>
                </ul>
            </li>
        </ul>
    </section>
    
    <section>
        <h2>6. Differentiation Between Trees and Graphs</h2>
        <table>
            <tr>
                <th>Feature</th>
                <th>Tree</th>
                <th>Graph</th>
            </tr>
            <tr>
                <td>Definition</td>
                <td>A hierarchical data structure with nodes connected by edges.</td>
                <td>A general data structure with nodes (vertices) connected by edges (can be directed/undirected).</td>
            </tr>
            <tr>
                <td>Structure</td>
                <td>Connected and acyclic.</td>
                <td>May be connected or disconnected, cyclic or acyclic.</td>
            </tr>
            <tr>
                <td>Root</td>
                <td>Has a single root node.</td>
                <td>No concept of a root (unless it's a tree-based graph).</td>
            </tr>
            <tr>
                <td>Parent-Child Relationship</td>
                <td>Nodes follow a strict parent-child hierarchy.</td>
                <td>No strict hierarchy; any node can connect to any other node.</td>
            </tr>
            <tr>
                <td>Edges</td>
                <td>Exactly n−1 edges for n nodes.</td>
                <td>Can have any number of edges (up to n(n−1)/2 for undirected graphs).</td>
            </tr>
            <tr>
                <td>Traversal</td>
                <td>DFS and BFS, plus tree-specific traversals (inorder, preorder, postorder).</td>
                <td>Typically DFS and BFS, without hierarchy-based traversal.</td>
            </tr>
            <tr>
                <td>Cyclic Nature</td>
                <td>Always acyclic.</td>
                <td>Can contain cycles (e.g., directed graphs with loops).</td>
            </tr>
        </table>
    </section>
    
    <section>
        <h3>Tree Traversals</h3>
        <ul>
            <li>Preorder: Visit root → Left subtree → Right subtree.</li>
            <li>Inorder: Visit Left subtree → Root → Right subtree (used in BSTs for sorted order).</li>
            <li>Postorder: Visit Left subtree → Right subtree → Root.</li>
            <li>Level-order: Breadth-first traversal level by level.</li>
        </ul>
    </section>
    
    <section>
        <h3>Graph Traversals</h3>
        <ul>
            <li>Depth First Search (DFS)</li>
            <li>Breadth First Search (BFS)</li>
        </ul>
    </section>
    
    <section>
        <h3>Applications</h3>
        <p><strong>Trees:</strong> Efficient data storage and retrieval for dynamic datasets.</p>
        <p><strong>Graphs:</strong> Modeling user relationships and interactions.</p>
    </section>
    
    <section>
        <h2>7. Sorting and Searching Algorithms</h2>
        <table>
